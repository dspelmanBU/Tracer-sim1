<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tracer Study: CSTR → PFR (with recycle)</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; background: #0b0f14; color: #e8eef6; }
    h1 { font-size: 18px; margin: 0 0 12px 0; }
    .grid { display: grid; grid-template-columns: 360px 1fr; gap: 16px; align-items: start; }
    .panel { background: #121925; border: 1px solid #1f2a3a; border-radius: 14px; padding: 14px; }
    .row { display: grid; grid-template-columns: 1fr 120px; gap: 10px; align-items: center; margin: 10px 0; }
    label { font-size: 13px; color: #cfe0f6; }
    input[type="range"] { width: 100%; }
    .val { font-variant-numeric: tabular-nums; text-align: right; color: #a9c4e8; }
    .btns { display: flex; gap: 10px; margin-top: 12px; }
    button {
      background: #1b2a40; color: #e8eef6; border: 1px solid #2a3e5c;
      border-radius: 10px; padding: 9px 12px; cursor: pointer;
    }
    button:hover { background: #22344f; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .schematic { display: grid; grid-template-columns: 1fr 48px 1fr; gap: 10px; align-items: center; margin-top: 10px; }
    .box {
      height: 80px; border-radius: 14px; border: 1px solid #2a3e5c;
      display: grid; place-items: center; font-weight: 600; position: relative;
      background: rgba(80, 160, 255, 0.06);
      overflow: hidden;
    }
    .box .fill {
      position: absolute; inset: 0;
      background: rgba(80, 160, 255, 0.1);
      opacity: 0.0;
      transition: opacity 80ms linear;
    }
    .box .txt { position: relative; z-index: 1; }
    .arrow {
      height: 2px; background: #2a3e5c; position: relative;
    }
    .arrow::after {
      content: ""; position: absolute; right: -2px; top: -4px;
      border-left: 10px solid #2a3e5c;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
    }

    #plot { height: 520px; }
    .note { font-size: 12px; color: #b8cbe6; line-height: 1.35; margin-top: 10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <h1>Tracer Study Simulator: CSTR → PFR (optional recycle)</h1>

  <div class="grid">
    <div class="panel">
      <div class="row">
        <label for="Q">Fresh flow Q (L/min)</label>
        <div class="val"><span id="Qv"></span></div>
        <input id="Q" type="range" min="1" max="50" step="0.5" value="10" style="grid-column: 1 / -1;">
      </div>

      <div class="row">
        <label for="Vc">CSTR volume V<sub>CSTR</sub> (L)</label>
        <div class="val"><span id="Vcv"></span></div>
        <input id="Vc" type="range" min="5" max="500" step="1" value="100" style="grid-column: 1 / -1;">
      </div>

      <div class="row">
        <label for="Vp">PFR volume V<sub>PFR</sub> (L)</label>
        <div class="val"><span id="Vpv"></span></div>
        <input id="Vp" type="range" min="5" max="500" step="1" value="150" style="grid-column: 1 / -1;">
      </div>

      <div class="row">
        <label for="r">Recycle fraction r (0 to 0.9)</label>
        <div class="val"><span id="rv"></span></div>
        <input id="r" type="range" min="0" max="0.9" step="0.01" value="0.20" style="grid-column: 1 / -1;">
      </div>

      <div class="row">
        <label for="M">Pulse mass M (mg)</label>
        <div class="val"><span id="Mv"></span></div>
        <input id="M" type="range" min="10" max="2000" step="10" value="500" style="grid-column: 1 / -1;">
      </div>

      <div class="row">
        <label for="dt">Time step dt (min)</label>
        <div class="val"><span id="dtv"></span></div>
        <input id="dt" type="range" min="0.02" max="0.5" step="0.01" value="0.05" style="grid-column: 1 / -1;">
      </div>

      <div class="row">
        <label for="tend">Duration (min)</label>
        <div class="val"><span id="tendv"></span></div>
        <input id="tend" type="range" min="5" max="120" step="1" value="40" style="grid-column: 1 / -1;">
      </div>

      <div class="btns">
        <button id="runBtn">Run</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn">Reset</button>
      </div>

      <div class="schematic">
        <div class="box" id="cstrBox">
          <div class="fill" id="cstrFill"></div>
          <div class="txt">CSTR</div>
        </div>
        <div class="arrow"></div>
        <div class="box" id="pfrBox">
          <div class="fill" id="pfrFill"></div>
          <div class="txt">PFR</div>
        </div>
      </div>

      <div class="note">
        Model: CSTR ODE + PFR as pure time delay (<span class="mono">τ = V/Q</span>). Recycle mixes PFR outlet back into the CSTR influent.
        This is deliberately “ideal” so students can see the core ideas without extra complexity.
      </div>
    </div>

    <div class="panel">
      <div id="plot"></div>
      <div class="note">
        Plots: Fresh inlet concentration <span class="mono">C_in,fresh</span> (pulse), CSTR concentration <span class="mono">C_CSTR</span>, and final outlet <span class="mono">C_out</span>.
      </div>
    </div>
  </div>

<script>
(() => {
  // ---- UI elements
  const els = {
    Q: document.getElementById('Q'),
    Vc: document.getElementById('Vc'),
    Vp: document.getElementById('Vp'),
    r: document.getElementById('r'),
    M: document.getElementById('M'),
    dt: document.getElementById('dt'),
    tend: document.getElementById('tend'),
    Qv: document.getElementById('Qv'),
    Vcv: document.getElementById('Vcv'),
    Vpv: document.getElementById('Vpv'),
    rv: document.getElementById('rv'),
    Mv: document.getElementById('Mv'),
    dtv: document.getElementById('dtv'),
    tendv: document.getElementById('tendv'),
    runBtn: document.getElementById('runBtn'),
    pauseBtn: document.getElementById('pauseBtn'),
    resetBtn: document.getElementById('resetBtn'),
    cstrFill: document.getElementById('cstrFill'),
    pfrFill: document.getElementById('pfrFill'),
  };

  function fmt(x, digits=2) {
    return Number(x).toFixed(digits);
  }

  function syncLabels() {
    els.Qv.textContent = fmt(els.Q.value, 1);
    els.Vcv.textContent = fmt(els.Vc.value, 0);
    els.Vpv.textContent = fmt(els.Vp.value, 0);
    els.rv.textContent = fmt(els.r.value, 2);
    els.Mv.textContent = fmt(els.M.value, 0);
    els.dtv.textContent = fmt(els.dt.value, 2);
    els.tendv.textContent = fmt(els.tend.value, 0);
  }

  // ---- Simulation state
  let running = false;
  let t = 0;

  // Time series storage
  let T = [], CinFresh = [], CCSTR = [], Cout = [];

  // States
  let c_cstr = 0;
  let c_out = 0;

  // PFR delay buffer (stores CSTR effluent values that will emerge after tau)
  let pfrBuffer = [];
  let pfrSteps = 1;

  function getParams() {
    const Q = Number(els.Q.value);          // L/min (fresh flow)
    const Vc = Number(els.Vc.value);        // L
    const Vp = Number(els.Vp.value);        // L
    const r  = Number(els.r.value);         // recycle fraction (flow recycle = r*Q)
    const M  = Number(els.M.value);         // mg (pulse mass)
    const dt = Number(els.dt.value);        // min
    const tEnd = Number(els.tend.value);    // min

    const Qrec = r * Q;
    const Qtot = Q + Qrec;

    const tau = Vp / Qtot;                  // min, time delay through PFR

    return { Q, Vc, Vp, r, M, dt, tEnd, Qrec, Qtot, tau };
  }

  function initSim() {
    const { dt, tau } = getParams();
    t = 0;
    c_cstr = 0;
    c_out = 0;

    // Delay length in steps; ensure >= 1
    pfrSteps = Math.max(1, Math.round(tau / dt));
    pfrBuffer = new Array(pfrSteps).fill(0);

    T = [];
    CinFresh = [];
    CCSTR = [];
    Cout = [];

    // Initialize plot
    const data = [
      { x: [], y: [], name: 'C_in,fresh (mg/L)', mode: 'lines' },
      { x: [], y: [], name: 'C_CSTR (mg/L)', mode: 'lines' },
      { x: [], y: [], name: 'C_out (mg/L)', mode: 'lines' },
    ];

    const layout = {
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      margin: { l: 52, r: 16, t: 10, b: 42 },
      xaxis: { title: 'Time (min)', gridcolor: 'rgba(255,255,255,0.08)', zerolinecolor: 'rgba(255,255,255,0.12)' },
      yaxis: { title: 'Concentration (mg/L)', gridcolor: 'rgba(255,255,255,0.08)', zerolinecolor: 'rgba(255,255,255,0.12)' },
      legend: { orientation: 'h', y: 1.08 },
      font: { color: '#e8eef6' }
    };

    Plotly.newPlot('plot', data, layout, { responsive: true, displayModeBar: false });
    updateSchematic(0, 0, 1);
  }

  function updateSchematic(cCstr, cPfr, cScaleMax) {
    // Map concentration to opacity using a soft saturation
    const norm = (c) => {
      const x = cScaleMax > 0 ? c / cScaleMax : 0;
      // gentle saturating curve so small values show up
      const y = 1 - Math.exp(-3 * Math.max(0, x));
      return Math.min(1, Math.max(0, y));
    };
    const o1 = norm(cCstr);
    const o2 = norm(cPfr);
    els.cstrFill.style.opacity = String(0.05 + 0.9 * o1);
    els.pfrFill.style.opacity  = String(0.05 + 0.9 * o2);
  }

  function stepOnce() {
    const { Q, Vc, r, M, dt, Qtot, tEnd } = getParams();

    // Fresh inlet pulse: inject all mass over first time step as an equivalent concentration
    // mass rate = Q * Cin (mg/min) => Cin = (M/dt) / Q
    const cin_fresh = (t < dt) ? ( (M / dt) / Q ) : 0; // mg/L because Q is L/min, M mg

    // Recycle mixing: influent to CSTR is a flow-weighted mix of fresh + recycle
    // recycle flow = r*Q, recycle concentration = c_out (PFR outlet)
    const cin_total = (Q * cin_fresh + (r * Q) * c_out) / Qtot;

    // CSTR dynamics: dC/dt = (Qtot/Vc)*(Cin_total - C)
    const k = Qtot / Vc;
    c_cstr = c_cstr + dt * k * (cin_total - c_cstr);

    // PFR as pure time delay of CSTR effluent
    pfrBuffer.push(c_cstr);
    c_out = pfrBuffer.shift();

    // Store time series
    T.push(t);
    CinFresh.push(cin_fresh);
    CCSTR.push(c_cstr);
    Cout.push(c_out);

    // Advance time
    t += dt;

    // Update schematic scaling based on max observed so far (avoid huge spike dominating forever)
    const recentMax = Math.max(1e-9, ...Cout.slice(Math.max(0, Cout.length - 400)));
    updateSchematic(c_cstr, c_out, recentMax);

    // Push to plot every few points for performance
    const pushEvery = 3;
    if (T.length % pushEvery === 0) {
      Plotly.extendTraces('plot', {
        x: [[T[T.length-1]], [T[T.length-1]], [T[T.length-1]]],
        y: [[CinFresh[CinFresh.length-1]], [CCSTR[CCSTR.length-1]], [Cout[Cout.length-1]]]
      }, [0, 1, 2], 2000);
    }

    // stop condition
    if (t > tEnd) stop();
  }

  function tick() {
    if (!running) return;
    // Do multiple sim steps per animation frame to keep it moving smoothly
    for (let i = 0; i < 10; i++) stepOnce();
    requestAnimationFrame(tick);
  }

  function run() {
    if (running) return;
    running = true;
    els.runBtn.disabled = true;
    els.pauseBtn.disabled = false;
    tick();
  }

  function stop() {
    running = false;
    els.runBtn.disabled = false;
    els.pauseBtn.disabled = true;
  }

  function reset() {
    stop();
    initSim();
  }

  // ---- Wire up UI changes
  const sliders = [els.Q, els.Vc, els.Vp, els.r, els.M, els.dt, els.tend];
  sliders.forEach(s => s.addEventListener('input', () => {
    syncLabels();
    // Reinitialize on parameter change to keep behavior predictable
    reset();
  }));

  els.runBtn.addEventListener('click', run);
  els.pauseBtn.addEventListener('click', stop);
  els.resetBtn.addEventListener('click', reset);

  // ---- Boot
  syncLabels();
  initSim();
})();
</script>
</body>
</html>
